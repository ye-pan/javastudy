# 重构——改善既有代码的设计

## 有一次从头开始

三个月前已经读过一遍了，但去尝试精读一些书籍，是从六月开始的，所以我决定重读一遍。只为将所有重构手法了然于胸，将重构做到如书中所描绘的，
就是日常 开发工作。为什么我要这么重视重构以及重构的基本手法，我见过了因为项目的烂代码而不得不重写的，也见到过 写过烂代码，但我希望以后的
我，就算是真的产生了烂代码，我也会去经常性的重构它，直到完善为止。书中所描绘的有讲究的，一次一小步的重构，以后的开发中我也需要做到。

## 前言

重构：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度
的减少整理过程中引入错误的概率。本质上说，重构就是在代码写好之后改进它的设计。

## 重构——第一个案例

重构就是以微小的步伐修改程序，如果你犯下错误，很容易便可发现它。

任何一个傻瓜都能够写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。

### 用到的重构手法

1. extract method
2. rename 
3. move method 
4. Replace Temp with Query
5. Replace Conditional with Polymorphism
6. Self Encapsulate Field 
7. Replace Type Code With State/Strategy

### 总结

开篇一个demo，向我们展示了重构，是什么，平时开发怎么做，有什么效果。跟着这个demo做了，对重构有了一个初步认识，需要接下来继续学习。其中，
这个例子中展现的所有重构手法，均已经亲自操作过，对为什么这么做也了解了。

## 重构原则

### 何谓重构

1. 对软件内部结构的一种调整，目的是在不改变软件可观察的前提下，提高其可理解性，降低修改成本。
2. 使用一系列重构手法，在不改变可观察行为的前提下，调整其结构。

两顶帽子：
使用重构技术开发软件时，你把自己的时间分配给两种截然不同的行为：添加新功能，以及重构。添加新功能时，你不应该修改既有代码，只管添加新功能。
通过测试（并让测试正常运行），你可以衡量自己的工作进度。重构时你就不能再添加新功能，只管改进程序结构，此时，你不应该添加任何测试（除非
发现先前遗漏的东西），只在绝对必要（用以处理接口变化）时，才修改测试。

### 为何重构

* 重构改进软件设计：如果没有重构，软件设计会逐渐腐败变质。
* 重构使软件更容易理解：
* 重构帮助找到bug：
* 重构提高变成速度：

### 何时重构

重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地的进行，你不应该为重构而重构，你之所以重构，是因为你想做别的什么事，而重构
可以帮助你把那些事做好。

* 三次法则：
* 添加功能时重构：
* 修补错误时重构：
* 复审代码时重构：

### 总结

这章是对重构定义的内容，作者描述的很多场景，现在的我甚至都还不能体会。但只要通过这些细节手法，一次一小步的前进，我终究也会达到作者书中
所描绘的层次。书中的一句话已经做了很到位的总结“我不是个伟大的程序员，我只是个有着一些优秀习惯的好程序员”。

## 代码的坏味道

这一章太重要了，专门整理了一个文档。参看[代码的坏味道](代码的坏味道.md)。

## 构筑测试体系

如果你想要进行重构，首要前提就是拥有一个可靠的测试环境。编写优良的测试程序，可以极大的提高我的编程速度。

* 确保所有测试都完全自动化，让他们检查自己的测试结果
* 一套测试就是一个强大的bug侦测器，能够大大的缩减查找bug的时间
* 需要添加特性的时候，先写相应的测试代码，编写测试还能使精力集中于该接口而非实现
* 频繁地运行测试，每次编译请把测试也考虑进去——每天至少执行每个测试一次
* 每当你收到bug报告，请先写一个单元测试来暴露这个bug

### 总结

单元测试，写代码者对这部分代码自测的痕迹，有很多作用，一 重构是依靠运行该测试，保证我所做的调整是符合功能逻辑的，二 通过单元测试检测出
大量的bug，提高效率，三 通过观察单元测试，加深对该功能的理解，对功能的每一次深入都伴随着更好的设计方案。最后，请把JUnit用起来。

## 重新组织函数

### Extract Method 提炼函数

重构效果参看[before/ExtractMethod](before/ExtractMethod.java) 和 [after/ExtractMethod](after/ExtractMethod.java)

提炼函数是经常使用的手法之一，目的是给一段逻辑找到合适的描述并提炼出来，给提炼的逻辑找一个合适的名称，可以使代码的表现力更强。看到*long
 method*或者某段逻辑需要大段地注释来说明，都可以考虑将其分解/提炼，这样这段逻辑就变成了更多由小函数组成的逻辑。逻辑中的临时变量或者函数
 参数会影响我们使用该方法，这时可以使用*Replace Temp Query*将临时变量去除。这段例子中的提炼函数的思考，正反映了实现模式中的对称性原则！
 
### Inline Method 内联函数

重构效果参看[before/InlineMethod](before/InlineMethod.java) 和 [after/InlineMethod](after/InlineMethod.java)

使用该方法主要在以下3点：
1. 一些简短的函数，它内部实现代码和函数名称具有同样的表现力，可以考虑将这些函数内联
2. 当面对一群组织不合理的函数时，可以考虑下将它们都内联到一个大函数中，再从这个大函数来重新组织代码
3. 如果使用了太多的间接层，而其中一些是不需要甚至影响阅读体验的，可以考虑将这些层内联

该方法主要是用于处理不必要的小函数，同时再重构一个*long method*的时候，你可能会有一些不合理的提取，可以使用该方法将代码还原。而间接层
过多的情况，基本是要重构，因为遇到的大部分抽象出方法过多的情况，几乎都会影响可读性。

### Inline Temp 内联临时变量

重构效果参看[before/InlineTemp](before/InlineTemp.java) 和 [after/InlineTemp](after/InlineTemp.java)

该方法主要用于去掉函数内部不必要的临时变量，临时变量太多会影响代码可读性，也会影响到*Extract Method*的实施。

### Replace Temp with Query 以查询取代临时变量 

重构效果参看[before/ReplaceTempWithQuery](before/ReplaceTempWithQuery.java) 和 [after/ReplaceTempWithQuery](after/ReplaceTempWithQuery.java)

程序用一个临时变量保存某一表达式的运算结果，将这个表达式提炼到一个独立函数，将这个临时变量的所有引用点替换为对新函数的调用，此后，新函数
就可以被其他函数使用。

临时变量的问题在于，它们时暂时的，而且只能在所属函数内使用，由于临时变量只能在所属函数内可见，所以它们会驱使你写出更长的函数。

不是说不能使用临时变量，而是函数中某些计算是通用的，将其提炼出来可以给更多的地方使用，而不是使用临时变量来保存一个计算结果后面的计算就
使用该变量，这么做，其他需要使用该变量的地方就只有copy了。一半通过该方法提炼出来的函数都是小函数，但具有很强的表达力和通用性，对于理解
使用它的地方的计算逻辑也有帮助，及代码可读性更高！

### Introduce Explaining Variable 引入解释性变量

重构效果参看[before/IntroduceExplainingVariable](before/IntroduceExplainingVariable.java) 和 [after/IntroduceExplainingVariable](after/IntroduceExplainingVariable.java)

就是将计算逻辑中一些表达式提取为一个临时变量，并将这个变量取一个更具解释性的名称，达到代码自解释的效果。书中的例子，最后作者用*extract
 method*再一次将例子进行重构！
 
### Split Temporary Variable 分解临时变量

重构效果参看[before/SplitTemporaryVariable](before/SplitTemporaryVariable.java) 和 [after/SplitTemporaryVariable](after/SplitTemporaryVariable.java)

程序中有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果，这种变量应该通过该重构方法，针对每次赋值，创造一个独立，
对应的临时变量。

往往分解临时变量是重构一个函数的起点，它的作用是消除函数内混乱的临时变量赋值关系，为*Replace Temp with Query*和*Extract Method*重构
的应用做准备。例子中，我进行了更进一步的重构，虽然有点催毛求疵的感觉，但确实增加了一些表现力！

### Remove Assignments to Parameters 移除对参数的赋值

重构效果参看[before/RemoveAssignmentsToParameters](before/RemoveAssignmentsToParameters.java) 和 [after/RemoveAssignmentsToParameters](after/RemoveAssignmentsToParameters.java)

函数内对一个参数进行赋值，可以改为以一个临时变量取代该参数的位置

Java的按值传递：
Java使用按值传递的函数调用方式，在所有地点Java都严格按照采用值传递方式。本质上说，对象的引用时按值传递的，因此我可以修改参数对象的内部
状态，但对参数对象重新赋值时没有以及的。

### Replace Method with Method Object 以函数对象取代函数

重构效果参看[before/ReplaceMethodWithMethodObject](before/ReplaceMethodWithMethodObject.java) 和 [after/ReplaceMethodWithMethodObject](after/ReplaceMethodWithMethodObject.java)

你有一个大型函数，其中对局部变量的使用使你无法采用*Extract Method*。将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段，
然后你就可以在同一个对象中将这个大型函数分解为多个小型函数。

### Substitute Algorithm 替换算法

将函数本体替换为另一个算法

这一重构手法并没有具体步骤，它告诉我们，如果发现某个方法由更清晰，更简洁，更高效的方式来实现的时候，要毫不犹豫的去重写，不要再上面继续
缝缝补补！

## Move Method 搬移函数

重构效果参看[before/Account#overdraftCharge](before/Account.java) 和 [after/AccountType#overdraftCharge](after/AccountType.java)


这个主要用来处理一个类中的某些方法对该类所引用的其它类的依赖程度比当前类的依赖程度高，就意味着可能需要将该方法搬移到他所依赖的那个类中，
要求个人对模块或者整个系统有一定程度的理解，不然很不好拿捏何谓依赖程度以及该搬移那些方法，重构到什么地点停下来。

## Move Field 搬移字段

重构效果参看[before/Account#interestRate](before/Account.java) 和 [after/AccountType#interestRate](after/AccountType.java)

该方法目的和效果与*move method*类似，主要是针对字段。

在类之间移动状态和行为，事重构过程必不可少的措施。随着系统的发展，你会发现自己需要新的类，并需要将现有的工作责任拖到新的类中，在这个星期
看似合理而正确的设计决策，到了下个星期可能不再正确。

## Extract Class 提炼类

重构效果参看[before/Person](before/Person.java) 和 [after/TelephoneNumber](after/TelephoneNumber.java)

某个类做了应该由两个类做的事。这时建立一个新类，将相关的字段和函数从就函数搬移到新类。

这种情况也是需要对正在开发的模块由一定程度的理解，不然非常不好区分需要重构类中的那些状态和行为，才能达到更好的责任分离。如果不能很好的
区分待重构的类中不同的责任，重构出来的类会很丑陋！

## Inline Class 将类内联化

目的和*Extract Class*相反，如果发现两个类相互依赖对方状态，则要考虑将其中一个类内联化。

## Hide Delegate 隐藏委托关系

重构效果参看[before/Person#getDepartment](before/Person.java) 和 [after/Person#getManager](after/Person.java)

将类中暴露了内部实现细节的一些行为封装起来，主要时一个类将自己引用的其他类直接暴露给了外部这种情况。通过*Hide Delegate*把原来暴露的引
用隐藏起来。

## Remove Middle Man 移除中间人

目的和*Hide Delegate*相反，如果随着客户类对细节的依赖越来越多，原来使用*Hide Delegate*的类可能会有很多类似的方法，完全成了中间人，
这是可以用*Remove Middle Man*把引用直接暴露出来。

## Introduce Foreign Method 引入外加函数

你需要为提供服务的类增加一个函数，但你无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。

## Introduce Local Extension 引入本地扩展

你需要为服务类提供一些额外函数，但你无法修改这个类。建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类