# 代码的坏味道

## Duplicated Code 重复代码

重构手法：
* extract method，提炼重复代码到一个方法
* pull up method，如果重复代码再不同的子类，可以将提炼出来的方放推到超类中
* from template method，如果代码只是相似，并非完全相同，那要通过模板模式，提炼相同逻辑

## Long Method 过长的方法

重构手法：
* extract method，99%的场景都能起作用
* replace temp with query，用来消除函数内大量的参数和临时变量
* introduce parameter object & preserve whole object，将过长的参数列表变得简洁些
* replace method with method object，如果以上都不能有效，考虑将这个方法提炼为一个对象

## Large Class 过大的类

重构手法：
* extract class，用于处理一个类单纯的有大量的状态和逻辑
* extract subclass，用于处理一个类有大量的状态和逻辑，但这些状态并非所有时候都存在
* extract interface，如果有大量的代码，且提炼了不同的逻辑，还可以根据客户端使用的不同逻辑，进一步提炼不同的接口

## Long Parameter List 过长的参数列表

重构手法：
* replace parameter with method，用向该对象发消息，取代参数形式
* preserve whole object，将来自同一个对象的一堆数据收集起来，并以对象替代它们
* introduce parameter object，

## Divergent Change 发散式变化

*SRP*

我们希望软件能够更容易被修改——毕竟软件再怎么说本来就该是“软”的。一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改。如果不能做到这点，你就嗅出了两种紧密相关的刺鼻味道中的一种了。

如果某个类经常因为不同的原因在不同的方向上发生变化，*Divergent Change*就出现了。针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应此变化。

重构手法：
* extract class，将因不同原因需要修改的部分，提炼到不同的类，这样每个类只会因为对应的原因而变化

## Shotgun Surgery 霰弹式修改

*ShotgunSurgery*类似*Divergent Change*，但恰恰相反，如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是*Shotgun Surgery*。

*Divergent Change*是指“一个类受到了多种变化的影响”，*Shotgun Surgery*则是指“一种变化引发多个类相应修改”。这两种情况下你都会希望整理代码，使“外界变化”与“需要修改的类”趋于一一对应。

重构手法：
* move method & move field，多个类不同的状态或逻辑受到同一个原因而变化，考虑将这些类中分布的不同状态，或逻辑放到一起
* inline class，如果没有合适的类安置提炼的方法和字段，考虑创造一个

## Feature Envy 依恋情结

函数对某个类的兴趣高过对自己所处类的兴趣，这种孺慕之情最通常的焦点便是数据。

* extract method，将逻辑中这部分提炼出来
* move method，将提炼出来的方法放到合适的类中

## Data Clumps 数据泥团

数据项就像小孩子，喜欢成群结队的待在一起，你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段，许多函数签名中相同的参数，这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。

重构手法：
* extract class，将分不到不同类中的相同字段或逻辑，提炼到同一个类中
* introduce parameter object & preserve whole object，用到这些字段的函数签名做对应修改

## Primitive Obsession 基本类型偏执

重构手法：
* replace data value with object，提炼值对象
* replace type code with class，替换类型编码
* replace type code with subclass & replace type code with state/strategy，如果类型码涉及到条件表达式

## Switch Statements switch惊悚现身

重构手法：
* extract method 
* move method 
* replace type code with subclass & replace type code with state/strategy
* replace conditional with polymorphism
* replace parameter with explicit methods
* introduce null object 

## Parallel Inheritance Hierarchies 平行继承体系

*Parallel Inheritance Hierarchies*其实是*Shotgun Surgery*的特殊情况。在这种情况下，每当你为某个类增加一个子类，必须也为另一个类相应的增加一个子类，如果你发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，便是闻到了这种坏味道。

重构手法：
* move method & move field，将这种平行继承体系的关系消除 

## Lazy Class 冗赘类

重构手法：
* collapse hierarchy 消除继承体系
* inline class 消除不必要的类

## Speculative Generality 夸夸其谈未来性

重构手法：
* collapse hierarchy 消除不必要地继承体系
* inline class 消除不必要地类
* remove parameter 消除不必要地参数
* rename method 消除不必要的方法

## Temporary Field 令人迷惑的暂时字段

重构手法：
* extract class 将这些暂时性地字段提炼到一个类中，再使用这个类
* introduce null object 用 空对象取代 null地情况，避免条件表达式或者NPE

## Message Chains 过度耦合的消息链

重构手法：
* hide delegate，
* extract method，把使用消息链的方法提炼到一个方法中
* move method，将该方法推入消息链

## Middle Man 中间人

重构手法：
* remove middle man，消除中间人
* inline method，消除不必要的方法包装
* replace delegation with inheritance

## Inappropriate Intimacy 狎昵关系

重构手法：
* move method & move field，将两个类中关系过分紧密的字段或方法放在一起
* extract class，将两个类共同点提炼到新的类
* replace inheritance with delegation，如果子类过分依赖超类，可能说明可以不用继承而是用引用

## Alternative Classes with Different Interfaces 异曲同工的类

重构手法：
* rename method，
* move method，
* extract superclass，

## Incomplete Library Class 不完美的库类

重构手法：
* move method，
* introduce foreign method，
* introduce local extension，

## Data Class 纯稚的数据类

重构手法：
* encapsulate field，隐藏暴露的公共字段
* encapsulate collection，隐藏暴露的集合接口
* remove setting method，消除不必要的setter
* move method，尝试将调用点的部分涉及该类的逻辑移到该类中
* extract method，提炼调用点可以迁移的逻辑
* hide method，隐藏不必要的setter，getter

## Refused Bequest 被拒绝的遗赠

重构手法：
* push down method & push down field，将超类中的方法或字段放到实际使用它的子类中

## Comments 过多的注释

过多的注释意味着该函数有太多的意义，需要大段的注释来说明。

重构手法：
* extract method，提炼其中的逻辑
* rename method，取更有意义的名称
* introduce assertion，如果有些需求规格，可以考虑用断言来尝试说明
