# 实现模式

程序员为不断重复的琐事耗费的时间越少，他们就有越多的时间来解决好真正独一无二的问题，从而更高效的编程。

绝大多数程序都遵循一组简单的法则：

* 跟多的时候，程序是在被阅读，而不是被修改
* 没有“完工”一说。修改程序的投入会远大于最初编写程序的投入
* 程序都由一组基本的语句和控制流概念组合而成
* 程序的阅读者需要理解程序——即从细节上，也从概念上。有时他们从细节开始，逐渐理解概念；
有时他们从概念开始逐渐理解细节。

## 一种编程理论

### 价值观

#### 读书笔记

1. 沟通，如果阅读者可以理解某段代码，并且进一步修改或使用它，那么这段代码的沟通效果就很好。
在编程时，我们很容易从计算机的角度进行思考，但只有一面编程一面考虑其他人的感受，我才能编写出好
的代码。
2. 简单，去掉复杂性可以让那些阅读，使用和修改代码的人更容易理解。在各个层次上都应当要求简单，
对代码进行调整，删除所有不提供信息的代码，设计中不出现无关元素。对需求提出质疑，找出最本质的概念。
沟通和简单通常都是不可分割的，多余的复杂性越少，系统就越容易理解；在沟通方面投入的越多，
就越容易发现应该被抛弃的复杂性。不过有时候我也会发现某种简化会使程序难以理解，
这种情况下我会优先考虑沟通这样的情形很少，但常常都表示这里应该有一些我尚未察觉的更大规模的简化。
3. 灵活，是衡量那些低效编码与设计实践的一把标尺。程序是应该灵活，但只有在发生变化的时候才需如此。
想象中明天或许会用的上的灵活性，可能与真正修改代码时所需要的灵活性不是一回事。这就是简单性和大规
模测试所带来的灵活性比专门设计出来的灵活性更为有效的原因。要选择那些提倡灵活性并能够带来及时收益
的模式。增进软件的沟通效果同样也会提高灵活性，能够快速阅读，理解和修改你代码的人越多，它将来发生
变化的选择就越多！

文学编程：程序应该读起来像一本书一样，它需要有情节和韵律，句子间应该有优雅的小小跌宕起伏。

#### 个人总结

沟通，简单，灵活就是我们coder的价值观。沟通能力强并不是侃大山牛逼，而是需要我们从最根本的想法上，
要站在他人的角度去看待事情，去coding。在写下这段代码时，我们是否考虑过以后看到这段代码的人的想法
（包括未来的自己）。写出可读性很高的代码就是我们coder间最好的沟通方式。读到后面发现，
这里说的沟通指的应该是通过代码来沟通！

写简单的，贴近业务逻辑的代码，这个功能的代码描述不应该出现除这块功能以外的其他的代码。
随着我们对业务的理解，我们对这块功能的理解，可能和昨天写下这段代码时的理解时不一样的，
这是后就要带上重构的帽子，让这段代码变得简单而不是为了实现当前的功能而在已有的代码上缝缝补补！
最重要的，理解需求，明白需求下最本质的问题，抓住问题的本质，再考虑这个需求的设计是否合理，
是否有更好的解决方案！

不要以灵活性为借口，将coding变成了单纯的炫技。功能往往只有在经过线上的迭代，经过用户的使用，
最后我们可能才会知道到底哪里需要灵活。不要刻意为了明天的灵活性，而增加今天代码的复杂度。
只有当这里增加的灵活性能够切实的为我们带来业务价值，这个才是值得的！

### 原则

#### 读书笔记

1. 局部化影响，组织代码结构时，要保证变化智慧产生局部化的影响。如果这里的一个变化会引出那里的一
个问题，纳闷变化的代价就会急剧上升了，把影响范围缩到最小，代码就会有极佳的沟通效果。它可以被逐步
深入理解，不必一开始纪要鸟瞰全景。因为实现模式背后一条最主要的动机就是减少变化所引起的代价，所以
局部化影响这条原则也是很多模式的形成缘由之一！

2. 最小化重复，最小化重复这条原则有助于保证局部化影响，如果相同的代码出现在很多地方，
那么改动其中一处副本，就不得不考虑是否需要修改其他副本，变动不再只发生在局部。代码复制的越多，
变化的代价就越大。复制代码，并行的类层次结构都是重复的一种形式。重复不容易被预见到，
有时在出现以后一段时间才会被察觉，重复不是罪过，他只是增加了变化的开销。我们可以把程序拆分成许多
更小的部分——小段语句，小段方法，小型对象和小型包，从而消除重复。大段逻辑很容易与其他大段逻辑出现
重复地代码片段，于是就有了模式诞生地可能。

3. 将逻辑与数据绑定，局部化影响地必然结果就是将逻辑与数据捆绑，把逻辑与逻辑所处理地数据放在一起，
如果有可能，尽量放到一个方法中，或者退一步，放到一个对象里，最起码也要放到一个包下面，在发生变化时，
逻辑和数据可能会同时被改动。如果它们被放在一起，那么修改他们所造成地影响就会只停留在局部。

4. 对称性，程序中处处充满了对称性，比如add()方法总会伴随着remove()方法，一组方法会接受同样地参数，
一个对象中所有的字段都具有相同的声明周期。识别出对称性，把它清晰的表述出来，代码将更容易阅读，一旦
阅读者理解了对称性所涵盖的某一半，他们就很快地理解另外一半。在准备消灭重复之前，常常需要寻找并表示出
代码中的对称性，如果在很多代码中都存在类似的想法，那么可以先把他们用对称的方式表示出来，让接下来的
重构有一个良好的开端。

5. 声明表达式，尽可能声明式的表达出意图，命令式的编程语言功能强大灵活，但是在阅读时需要跟随代码的执
行流程，我必须在大脑中建起一个程序状态，控制流和数据流的模型。对于那些只是陈述简单事实，不需要一系列
条件语句的程序片段，如果用简单的声明式写出来，读着就容易多了。

6. 变化率，把具有相同变化率的逻辑，数据放在一起，把具有不同变化率的逻辑，数据分离。变化率具有时间上的
对称性，有时候可以将变化率原则应用于人为的变化。

#### 个人总结

原则这一章，总体看来已经很贴近我们日常编程了，这几点原则也是可以直接运用于实际开发中，帮助我们组织程
序，代码及类结构。《重构》中的代码的坏味道一章，很多观念和这里不谋而合，可能时因为时同一个作者的缘故。
但从中我们可以看见，这些真的时作者的经验之谈了，每个可以讨论的促进编程手艺的场合，他都在传播这些经验。

其中，局部化影响，很容易理解，同时也是我们平时开发时所期望的。需求是会随着时间以及应用场景的变化而变化
的，我们能做的是期望能够在真正修改时，能够只改动相关功能涉及的代码。最小化重复，就更不多说，重复时开发
的万恶之源，DRY早已深入人心。4，5，6现在的我没有很深刻的体验。

## 动机

### 读书笔记

软件设计的底层驱动力是经济学，软件设计应该致力于减少整体成本，软件成本可以被分解为初始成本（开发）
和维护成本。软件的维护成本要远远高于它的初始成本。维护的代价很大，这是因为理解现有代码需要花费时间，
而且容易出错。知道了需要修改什么以后，做出改动就变得轻而易举了，掌握现在的代码做了哪些事情是需要花
费人力物力的部分，改动之后，还要进行测试和部署。

减少整体成本的策略之一是在初期的开发中投入更多精力，希望借此减少甚至消除维护的需要。这些做法往往会
失败。一旦代码以未预期的方式发生变化，人们曾经所作出的任何预见都不再是万全之策，人们可能会为了预备
将来发生的变化而过早考虑代码的通用性，但如果出现了没有预料到而又势在必行的变化，先前的做法往往就会
与现实发生冲突。

从本质上看，增加软件的先期投入是与两条重要的经济学原则——金钱的时间价值和未来的不确定性，相悖的!
今天的一元钱比明天的一元钱更值钱，所以从原则上讲，我们的实现策略应该是尽量将支出推后，同样由于不
确定性的存在，实现策略应该更倾向于带来及时收益而非长远收益。一方面着眼于获得及时收益，另一方面也
在创建干净的代码，以方便将来的开发工作。

用来减少整体成本的策略是，所有开发人员在进行维护的时候注重程序员与程序员之间的沟通，减少理解代码
所带来的代价。清晰明确代码会带来及时收益：代码缺陷更少，更易共享，开发曲线更加平滑。

### 我的理解

代码来自于人，服务于人。软件的维护成本要远远大于开发成本，我们只有通过及时的沟通并理解对应维护的功
能点，才可能尽力减少维护这个功能的成本。别忘了前面的价值观——沟通，沟通在代码中，所以写出可读性很高
的代码也很重要。还有，应该避免为了明天的灵活性，而在今天的代码中加入过多的预见性代码，这是很不划算
的，在大大的增加了今天设计开发的工作任务同时，可能我们对于明天的预见是错误的，而一旦在明天得到证实
，那么我们今天设计全都是无用功！

## 类

### 读书笔记

面向对象编程把程序划分成许多类，类是对一组相似的东西的一般归纳，而对象则是这些东西本身。类对于沟通很
重要，因为他们可以描述很多具体的东西。实现模式最大的跨度只到类一级。

类：数据的变化比逻辑要频繁的多，正是这种现象让类有了存在的意义，每个类其实就是这样一个声明：这些逻辑
应该放在一起，他们的变化不想他们所操作的数据那么频繁，这些数据也应该放在一起，他们变化的频率差不多，
并且由与之关联的逻辑来负责处理。学会如何用类来包装逻辑和如何表达逻辑的变化，这是有效使用对象编程的重
要部分。在由对象搭建而成的程序中，类是相对昂贵的设计元素。一个类应该做一些有直接而明显的意义的事情。
减少类的数量是对系统的改进，只要剩下的类不因此而变得臃肿就好。

简单的超类名：找到一个贴切的名字是编程中最令人开心的时刻之一，贴切的名字能引发连锁反应，带来更深入的
简化与改进。类名的“简短”与“表现力”之间存在张力。有时候需要强迫自己找到一个好名字，抽出一本辞典，写下
所有多少有些接近的名字，站起来走一走，另一些时候应该带着挫败感和对时间的信息先去考虑新功能的实现，潜
意识会默默起作用的。交谈总能帮助我想出更好的名字，要尝试把一个类的用途解释给别人听，我就的寻找具有表
现力和感染力的图景来描述它，这样的图景往往能引出新的名字。对于重要的类，尽量用一个单词来为它命名。

限定性的子类名：子类的名字有两重职责，不仅要描述这些类像什么，还要说明它们之间的区别是什么。同样在
这里需要权衡长度与表现力，与位于继承体系根上的超类不同，子类的名字在交谈中用的并不频繁，所以值得以
牺牲简明来换取更好表现力。如果继承只是用作共享实现的机制，并且子类本身就代表一个重要的概念，那么这样
的子类就应该被视为他自己的继承体系的根，拥有一个简单的名字。不要不假思索的在直接超类的基础上扩展出
子类名，要多从阅读者的角度来想想阅读者需要了解这个类的什么信息，应该带着这个思考，以超类名为参考来给
子类命名。

抽象接口：针对接口编程，不要针对实现编程。从另一个角度来说，这也意味着设计决策不应该暴露给不必要的地方
。并不是接口数量越多软件成本就会越少，只有需要接口带来灵活性时才值得为它付出成本。引入接口时的另一个经
济方面的考量是软件的不可预测性。为什么我们不能一次列出系统中所有需要灵活性的地方呢？因为需求和技术都在
以不可预测的方式变化。

interface：用Java表达，这是我要完成的任务，除此之外的细节不归我操心，可以声明一个interface。interface
是一个很好的平衡，他带来了多继承的一部分灵活性，同时又没有多继承复杂性和二义性。如果说interface让改变
的工作更加轻松，那么不能不提的就是对接口本身的修改是不被鼓励的，一旦在interface上增加或者修改方法，就
必须同时改变所有的实现类，如果无权改变实现，大量使用interface会严重拖累日后的设计调整。

抽象类：Java中区分抽象接口与具体实现的另一种方式是使用超类。何时应该使用超类 合适应该使用interface？
取舍最终归结为两点：接口会如何变化，实现类是否需要同时支持多个接口。抽象接口需要支持实现的变化以及接口
本身的变化两种类型的变化。Java的interface对后者的支持不佳，一旦改变interface所有的实现类都必须同时
修改。如果要修改一个有很多实现类的interface，很容易导致现有的设计陷入瘫痪，以至只好借助有版本的inter
-face来调整设计。抽象类没有这方面的限制，只要提供了默认实现，在抽象类中新增的操作就不会侵扰现有的实现
类。抽象类的局限体现在实现类必须对其忠心不二，如果需要以另一种视角来看待同一个实现类，就只能让它实现
interface。

有版本的interface：

值对象：把具有可变状态的对象最为思考计算问题的一种方式确实很有价值，但它并非唯一的方式。当问题可以被归
约到由绝对真实和确定构成的，在其中可以以谈论“永恒真理”的抽象世界，另一种思考这类问题的方式已经发展了数
千年，那就是数学。过程式的接口比函数式的接口更常见，过程式接口的一个问题，是过程调用的顺序成为了接口含
义的重要组成部分，修改这样的程序非常困难，需要格外小心，你可能制作了一点小小的改变，却不留神改变了调用
的顺序，从而破坏了其中隐藏的接口含义，并以此带来意料之外的影响。

特化：清晰的描述计算过程中相似性与差异性的相互作用，可以让程序更容易阅读，使用和修改。在实际工作中，没
有哪段代码是独一无二的。不同程序会表达相似的概念，同样一个程序中的很多部分往往也在表达着相似的概念，清
晰的描述相似性和差异性，就能让阅读者更好的理解现有代码，找出自己想要做的事情是否已经被某种现有的各种实
现所覆盖，以及——如果还没有现成实现——如何对现有代码加以特化或是编写新的代码以满足需求。

子类：声明一个子类就是在说，这些对象与那些对象很类似，只除了……如果有个适当的超类，创建子类会是一种强
大的编程方式，通过覆盖适当的方法，只需几行代码就可以为现有的计算逻辑引入变化。

实现器：在由对象组成的程序中，多态消息是表达选择的基本方法之一，为了让消息能起到选择的作用，能够接收
到该消息的对象就必须不止一种。

内部类：

实例特有的行为：

条件语句：

委派：

可插拔的选择器：

匿名内部类：

库类：


### 我的理解：

前半章主要讲述了基本编程元素类，抽象类，接口，有版本的接口，值对象等，通过类命名这一方面来说明了抽象类
（超类）和具体类之间的异同，类时块业务功能的程序抽象，它的名称应该符合当前的场景，且具有隐喻的效果，让
人们再读到类名的时候就能将他带到应用场景里。接口作为Java里面最高层的抽象，设计建模的时后需要谨慎，只有
在真的需要接口这么高的抽象层次的时候，才去创建对应的接口，一旦接口创建完成，就不能轻易修改，如果真的需
要修改可以使用有版本的接口这种方式来临时处理，Java 8在接口中引入了*default*修饰符，也可以用于这种
情况，但是切记好的设计才是正确的做法，这些方式不过是设计真的出错而修改代价有很大的时候做的折中方案。值
对象是从函数式编程引入的概念，这里需要区分过程式，面向对象以及函数式三种编程风格的区别，理解了这三者的
确别以及适用的场景，才能在需要的时候用正确的风格设计出好的方案。

## 状态

