# 实现模式

程序员为不断重复的琐事耗费的时间越少，他们就有越多的时间来解决好真正独一无二的问题，从而更高效的编程。

绝大多数程序都遵循一组简单的法则：

* 跟多的时候，程序是在被阅读，而不是被修改
* 没有“完工”一说。修改程序的投入会远大于最初编写程序的投入
* 程序都由一组基本的语句和控制流概念组合而成
* 程序的阅读者需要理解程序——即从细节上，也从概念上。有时他们从细节开始，逐渐理解概念；
有时他们从概念开始逐渐理解细节。

## 一种编程理论

### 价值观

#### 读书笔记

1. 沟通，如果阅读者可以理解某段代码，并且进一步修改或使用它，那么这段代码的沟通效果就很好。
在编程时，我们很容易从计算机的角度进行思考，但只有一面编程一面考虑其他人的感受，我才能编写出好
的代码。
2. 简单，去掉复杂性可以让那些阅读，使用和修改代码的人更容易理解。在各个层次上都应当要求简单，
对代码进行调整，删除所有不提供信息的代码，设计中不出现无关元素。对需求提出质疑，找出最本质的概念。
沟通和简单通常都是不可分割的，多余的复杂性越少，系统就越容易理解；在沟通方面投入的越多，
就越容易发现应该被抛弃的复杂性。不过有时候我也会发现某种简化会使程序难以理解，
这种情况下我会优先考虑沟通这样的情形很少，但常常都表示这里应该有一些我尚未察觉的更大规模的简化。
3. 灵活，是衡量那些低效编码与设计实践的一把标尺。程序是应该灵活，但只有在发生变化的时候才需如此。
想象中明天或许会用的上的灵活性，可能与真正修改代码时所需要的灵活性不是一回事。这就是简单性和大规
模测试所带来的灵活性比专门设计出来的灵活性更为有效的原因。要选择那些提倡灵活性并能够带来及时收益
的模式。增进软件的沟通效果同样也会提高灵活性，能够快速阅读，理解和修改你代码的人越多，它将来发生
变化的选择就越多！

文学编程：程序应该读起来像一本书一样，它需要有情节和韵律，句子间应该有优雅的小小跌宕起伏。

#### 个人总结

沟通，简单，灵活就是我们coder的价值观。沟通能力强并不是侃大山牛逼，而是需要我们从最根本的想法上，
要站在他人的角度去看待事情，去coding。在写下这段代码时，我们是否考虑过以后看到这段代码的人的想法
（包括未来的自己）。写出可读性很高的代码就是我们coder间最好的沟通方式。读到后面发现，
这里说的沟通指的应该是通过代码来沟通！

写简单的，贴近业务逻辑的代码，这个功能的代码描述不应该出现除这块功能以外的其他的代码。
随着我们对业务的理解，我们对这块功能的理解，可能和昨天写下这段代码时的理解时不一样的，
这是后就要带上重构的帽子，让这段代码变得简单而不是为了实现当前的功能而在已有的代码上缝缝补补！
最重要的，理解需求，明白需求下最本质的问题，抓住问题的本质，再考虑这个需求的设计是否合理，
是否有更好的解决方案！

不要以灵活性为借口，将coding变成了单纯的炫技。功能往往只有在经过线上的迭代，经过用户的使用，
最后我们可能才会知道到底哪里需要灵活。不要刻意为了明天的灵活性，而增加今天代码的复杂度。
只有当这里增加的灵活性能够切实的为我们带来业务价值，这个才是值得的！

### 原则

#### 读书笔记

1. 局部化影响，组织代码结构时，要保证变化智慧产生局部化的影响。如果这里的一个变化会引出那里的一
个问题，纳闷变化的代价就会急剧上升了，把影响范围缩到最小，代码就会有极佳的沟通效果。它可以被逐步
深入理解，不必一开始纪要鸟瞰全景。因为实现模式背后一条最主要的动机就是减少变化所引起的代价，所以
局部化影响这条原则也是很多模式的形成缘由之一！

2. 最小化重复，最小化重复这条原则有助于保证局部化影响，如果相同的代码出现在很多地方，
那么改动其中一处副本，就不得不考虑是否需要修改其他副本，变动不再只发生在局部。代码复制的越多，
变化的代价就越大。复制代码，并行的类层次结构都是重复的一种形式。重复不容易被预见到，
有时在出现以后一段时间才会被察觉，重复不是罪过，他只是增加了变化的开销。我们可以把程序拆分成许多
更小的部分——小段语句，小段方法，小型对象和小型包，从而消除重复。大段逻辑很容易与其他大段逻辑出现
重复地代码片段，于是就有了模式诞生地可能。

3. 将逻辑与数据绑定，局部化影响地必然结果就是将逻辑与数据捆绑，把逻辑与逻辑所处理地数据放在一起，
如果有可能，尽量放到一个方法中，或者退一步，放到一个对象里，最起码也要放到一个包下面，在发生变化时，
逻辑和数据可能会同时被改动。如果它们被放在一起，那么修改他们所造成地影响就会只停留在局部。

4. 对称性，程序中处处充满了对称性，比如add()方法总会伴随着remove()方法，一组方法会接受同样地参数，
一个对象中所有的字段都具有相同的声明周期。识别出对称性，把它清晰的表述出来，代码将更容易阅读，一旦
阅读者理解了对称性所涵盖的某一半，他们就很快地理解另外一半。在准备消灭重复之前，常常需要寻找并表示出
代码中的对称性，如果在很多代码中都存在类似的想法，那么可以先把他们用对称的方式表示出来，让接下来的
重构有一个良好的开端。

5. 声明表达式，尽可能声明式的表达出意图，命令式的编程语言功能强大灵活，但是在阅读时需要跟随代码的执
行流程，我必须在大脑中建起一个程序状态，控制流和数据流的模型。对于那些只是陈述简单事实，不需要一系列
条件语句的程序片段，如果用简单的声明式写出来，读着就容易多了。

6. 变化率，把具有相同变化率的逻辑，数据放在一起，把具有不同变化率的逻辑，数据分离。变化率具有时间上的
对称性，有时候可以将变化率原则应用于人为的变化。

#### 个人总结

原则这一章，总体看来已经很贴近我们日常编程了，这几点原则也是可以直接运用于实际开发中，帮助我们组织程
序，代码及类结构。《重构》中的代码的坏味道一章，很多观念和这里不谋而合，可能时因为时同一个作者的缘故。
但从中我们可以看见，这些真的时作者的经验之谈了，每个可以讨论的促进编程手艺的场合，他都在传播这些经验。

其中，局部化影响，很容易理解，同时也是我们平时开发时所期望的。需求是会随着时间以及应用场景的变化而变化
的，我们能做的是期望能够在真正修改时，能够只改动相关功能涉及的代码。最小化重复，就更不多说，重复时开发
的万恶之源，DRY早已深入人心。4，5，6现在的我没有很深刻的体验。

## 动机

### 读书笔记

软件设计的底层驱动力是经济学，软件设计应该致力于减少整体成本，软件成本可以被分解为初始成本（开发）
和维护成本。软件的维护成本要远远高于它的初始成本。维护的代价很大，这是因为理解现有代码需要花费时间，
而且容易出错。知道了需要修改什么以后，做出改动就变得轻而易举了，掌握现在的代码做了哪些事情是需要花
费人力物力的部分，改动之后，还要进行测试和部署。

减少整体成本的策略之一是在初期的开发中投入更多精力，希望借此减少甚至消除维护的需要。这些做法往往会
失败。一旦代码以未预期的方式发生变化，人们曾经所作出的任何预见都不再是万全之策，人们可能会为了预备
将来发生的变化而过早考虑代码的通用性，但如果出现了没有预料到而又势在必行的变化，先前的做法往往就会
与现实发生冲突。

从本质上看，增加软件的先期投入是与两条重要的经济学原则——金钱的时间价值和未来的不确定性，相悖的!
今天的一元钱比明天的一元钱更值钱，所以从原则上讲，我们的实现策略应该是尽量将支出推后，同样由于不
确定性的存在，实现策略应该更倾向于带来及时收益而非长远收益。一方面着眼于获得及时收益，另一方面也
在创建干净的代码，以方便将来的开发工作。

用来减少整体成本的策略是，所有开发人员在进行维护的时候注重程序员与程序员之间的沟通，减少理解代码
所带来的代价。清晰明确代码会带来及时收益：代码缺陷更少，更易共享，开发曲线更加平滑。

### 我的理解

代码来自于人，服务于人。软件的维护成本要远远大于开发成本，我们只有通过及时的沟通并理解对应维护的功
能点，才可能尽力减少维护这个功能的成本。别忘了前面的价值观——沟通，沟通在代码中，所以写出可读性很高
的代码也很重要。还有，应该避免为了明天的灵活性，而在今天的代码中加入过多的预见性代码，这是很不划算
的，在大大的增加了今天设计开发的工作任务同时，可能我们对于明天的预见是错误的，而一旦在明天得到证实
，那么我们今天设计全都是无用功！

## 类

### 读书笔记

类：数据的变化比逻辑要频繁的多，正是这种现象让类有了存在的意义，每个类其实就是这样一个声明：这些逻辑
应该放在一起，他们的变化不想他们所操作的数据那么频繁，这些数据也应该放在一起，他们变化的频率差不多，
并且由与之关联的逻辑来负责处理。学会如何用类来包装逻辑和如何表达逻辑的变化，这是有效使用对象编程的重
要部分。

在由对象搭建而成的程序中，类是相对昂贵的设计元素。一个类应该做一些有直接而明显的意义的事情。减少类的
数量是对系统的改进，只要剩下的类不因此而变得臃肿就好。

简单的超类名：对于重要的类，尽量用一个单词来为它命名。

限定性的子类名：子类的名字由两重职责，不仅要描述这些类像什么，还要说明它们之间的区别是什么。同样在
这里需要权衡长度与表现力。

抽象接口：针对接口编程，不要针对实现编程。从另一个角度来说，这也意味着设计决策不应该暴露给不必要的
地方。为什么我们不能一次列出系统中所有需要灵活性的地方呢？因为需求和技术都在以不可预测的方式变化。

interface：

抽象类：